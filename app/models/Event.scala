/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 Association du Paris Java User Group.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package models

import com.fasterxml.jackson.annotation.JsonSubTypes.Type
import com.fasterxml.jackson.annotation.{JsonSubTypes, JsonTypeInfo}
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.scala.DefaultScalaModule
import controllers.{Link, routes}
import library.Redis
import org.joda.time.{DateTime, Instant}
import play.api.i18n.Messages

/**
 * Entity to store all CFP events generated by speaker such as "I submitted a talk" or
 * "my talk was accepted".
 *
 * Author: @nmartignole
 * Created: 11/11/2013 09:39
 */

abstract class EventLink {
  def href: String
  def rel: String
  def title: String
  def icon: String
}

case class ProposalLink(proposalId: String, webuser: Webuser) extends EventLink {
  def href = (if(Webuser.isMember(webuser.uuid, "cfp")){ routes.CFPAdmin.openForReview(proposalId) }
             else { routes.GoldenTicketController.openForReview(proposalId) }).toString()

  def rel = routes.RestAPI.profile("proposal").toString()
  def title = proposalId
  def icon = "fa-sign-in-alt"
}

case class SpeakerLink(speakerUuid: String, speakerName: String) extends EventLink {
  def href = routes.CFPAdmin.showSpeakerAndTalks(speakerUuid).toString()
  def rel = routes.RestAPI.profile("speaker").toString()
  def title = speakerName
  def icon = "fa-user"
}

case class WishlistLink(requestId: String) extends EventLink {
  def href = routes.Wishlist.edit(requestId).toString()
  def rel = routes.RestAPI.profile("wishlist").toString()
  def title = requestId
  def icon = "fa-sort-amount-down"
}

/**
 * Event.
 * @param objRef is the unique ID of the object that was modified
 * @param uuid is the author, the person who did this change
 * @param msg is a description of what one did
 * @param date is the event ate
 */
@JsonTypeInfo(
  use = JsonTypeInfo.Id.NAME,
  include = JsonTypeInfo.As.PROPERTY,
  property = "kind")
@JsonSubTypes(Array(
  new Type(value = classOf[LegacyEvent], name = "Legacy")
))
abstract class Event {
  def creator: String
  def date: DateTime = new DateTime().toDateTime(ConferenceDescriptor.current().timezone)

  def message(): String
  def linksFor(webuser: Webuser): Seq[EventLink] = Seq()
  def timezonedDate(): DateTime = date.toDateTime(ConferenceDescriptor.current().timezone)
}

case class LegacyEvent(objRef: String, creator: String, msg: String)
  extends Event {
  override def message(): String = msg
}


object Event {
  val mapper = new ObjectMapper().registerModule(DefaultScalaModule)

  def storeEvent(event: Event) = Redis.pool.withClient {
    client =>
      val jsEvent = mapper.writeValueAsString(event)
      val tx = client.multi()
      tx.zadd("Events:V3", event.date.getMillis, jsEvent)
      tx.exec()
  }

  def loadEvents(items: Int, page: Int): List[Event] = Redis.pool.withClient {
    client =>
      client.zrevrangeWithScores("Events:V3", page * items, (page + 1) * items).map {
        case (json: String, date: Double) =>
          val event = mapper.readValue(json, classOf[Event])
          event
      }
  }

  // Very fast O(1) operation
  def totalEvents() = Redis.pool.withClient {
    client =>
      client.zcard("Events:V3")
  }

  def resetEvents() = Redis.pool.withClient{
    client=>
      client.del("Events:V3")
      val allEvents = client.keys("Events:*")
      val tx=client.multi()
      allEvents.foreach{k:String=>
        tx.del(k)
      }
      tx.exec()
  }

  implicit object mostRecent extends Ordering[DateTime] {
    def compare(o1: DateTime, o2: DateTime) = o1.compareTo(o2)
  }

  def loadEventsForObjRef(objRef: String): List[Event] = Redis.pool.withClient {
    client =>
      client.smembers(s"Events:V2:$objRef").flatMap {
        json: String =>
          Json.parse(json).asOpt[Event]
      }.toList
  }

  def getMostRecentDateFor(objRef: String): Option[DateTime] = Redis.pool.withClient {
    client =>
      client.get("Events:LastUpdated:" + objRef).map {
        s =>
          new Instant().withMillis(s.toLong).toDateTime
      }
  }

  def speakerNotified(speaker: Speaker, allApproved: Set[Proposal], allRejected: Set[Proposal], allBackups: Set[Proposal]) = Redis.pool.withClient {
    client =>
      client.sadd("NotifiedSpeakers", speaker.uuid)
      // Pas de backup et rien d'approuvÃ©
      if (allApproved.isEmpty && allBackups.isEmpty && allRejected.nonEmpty) {
        client.sadd("Notified:RefusedSpeakers", speaker.uuid)
      }
      if (allApproved.nonEmpty) {
        client.sadd("Notified:ApprovedSpeakers", speaker.uuid)
      }
      if (allApproved.isEmpty && allBackups.nonEmpty) {
        client.sadd("Notified:BackupSpeakers", speaker.uuid)
      }
  }

  def resetSpeakersNotified() = Redis.pool.withClient{
    client=>
      client.del("NotifiedSpeakers")
      client.del("Notified:RefusedSpeakers")
      client.del("Notified:ApprovedSpeakers")
      client.del("Notified:BackupSpeakers")
  }


}
