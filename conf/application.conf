# CFP for Devoxx
# Configuration file
# -------------------------------------------------------------------------------------
#
# All environment variables are set from the CleverCloud console for Production
# For local development, create a simple env.sh that will configure all variables.
# See run.sh.sample
#
# -------------------------------------------------------------------------------------
#
# Do not edit this file - use run.sh
#
application.secret=${APP_SECRET}
cfp.hostname=${CFP_HOSTNAME}
application.langs=${CFP_LANG}
logger.root=ERROR
logger.play=INFO
logger.application=DEBUG

smtp.host=${SMTP_HOST}
smtp.user=${SMTP_USER}
smtp.password=${SMTP_PASSWORD}
smtp.ssl=${SMTP_SSL}
smtp.port=${SMTP_PORT}
smtp.mock=${SMTP_MOCK}

# The sender, can be no-reply@yourdomain.com
mail.from=${MAIL_FROM}

# The CFP group of humans that is happy to review proposals
# For instance "program@mydomain.com"
mail.committee.email=${MAIL_COMMITTEE}

# Usually the CFP Group email alias with a "+notifications"
# For instance "program+notifications@mydomain.com"
mail.notification.email=${? MAIL_NOTIFICATION}

# Used for bug report
mail.bugReportRecipient=${MAIL_BUG_REPORT}

#mail.bcc=${MAIL_BCC}

# Github staging
github.client_id=${GITHUB_ID}
github.client_secret=${GITHUB_SECRET}

google.client_id=${GOOGLE_ID}
google.client_secret=${GOOGLE_SECRET}

linkedin.client_id=${LINKEDIN_CLIEND_ID}
linkedin.client_secret=${LINKEDIN_SECRET}

# Redis hosted on my server
# DO NOT USE the PROD server in Dev mode
redis.host=${REDIS_HOST}
redis.port=${REDIS_PORT}
redis.timeout=30000
redis.database=1
redis.password=${? REDIS_PASSWORD}

actor.cronUpdater.active=${CRON_UPDATER}
actor.draftReminder.days=${CRON_DAYS}

# CleverCloud prod
elasticsearch.host=${ES_ADDON_URI}
elasticsearch.username=${ES_ADDON_USER}
elasticsearch.password=${ES_ADDON_PASSWORD}

stats-context {
  fork-join-executor {
    parallelism-factor = 4.0
    parallelism-max = 32
  }
}

elasticsearch-context {
  fork-join-executor {
    parallelism-factor = 4.0
    parallelism-max = 32
  }
}

play {
  akka {
    event-handlers = ["akka.event.Logging$DefaultLogger", "akka.event.slf4j.Slf4jEventHandler"]
    loglevel = DEBUG
    log-config-on-start = off

    actor {
      default-dispatcher = {
   fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 8

        # The parallelism factor is used to determine thread pool size using the
        # following formula: ceil(available processors * factor). Resulting size
        # is then bounded by the parallelism-min and parallelism-max values.
        parallelism-factor = 3.0

        # Max number of threads to cap factor-based parallelism number to
        parallelism-max = 64
      }
      }
    }
  }
}

# Set to false will close the CFP for speakers
cfp.isOpen=${CFP_IS_OPEN}

akka.jvm-exit-on-fatal-error=false

# For AngularJS schedule application
# If the post is too small you won't be able to save your schedule updates
parsers.MultipartFormData.maxLength=10240K
parsers.json.maxLength=1M
parsers.text.maxLength=1M

ws.useragent="Play2 Scala WS for Devoxx"

akka.log-dead-letters-during-shutdown=false

# Set to true if you want to show Golden Ticket votes in the show vote view
goldenTicket.active=${ACTIVATE_GOLDEN_TICKET}

# Set to true if you have HTTPS enabled
cfp.activateHTTPS=${ACTIVATE_HTTPS}

# For SSL support
trustxforwarded=true

# Bucket name that stores static HTML pages from previous edition
# For prod on Clever-cloud it should be /app
# For dev it's a local folder on your system with HTML pages. It can be empty.
bucket.rootFolder=${BUCKET_ROOTFOLDER}

# open or close the votes for talks from mobile app
mobile.vote.isActive=${ACTIVATE_VOTE}

# Reset all votes when a DRAFT or SUBMITTED talk is updated
cfp.resetVotesForSubmitted=true
cfp.resetVotesForSubmitted=${? CFP_RESET_VOTES_SUBMITTED}

# Email Digest
# Daily is a 24h time setting, for example "08:00" or "17:00"
digest.daily=${DIGEST_DAILY}
# Day of the week, Monday = 1, etc.
digest.weekly=${DIGEST_WEEKLY}

# If set to true then send an email to program committee for each new proposal
# Else only the Digest email is used
cfp.notifyProposalSubmitted=false
cfp.notifyProposalSubmitted=${? CFP_NOTIFY_PROPOSAL_SUBMITTED}

# My Devoxx for Schedule : not mandatory but if defined, it lets you delegate the Visitor auth to an external service
mydevoxx.active=false
mydevoxx.active=${? USE_MY_DEVOXX}
mydevoxx.url=${? MY_DEVOXX_URL}
mydevoxx.jwtSharedSecret=${? MY_DEVOXX_SECRET}

# Send a SMS to speaker when their talk is about to start
cfp.twilioSMS.active=false
cfp.twilioSMS.active=${? TWILIO_SMS}
cfp.twilioSMS.accountSid=${? TWILIO_ACCOUNT_ID}
cfp.twilioSMS.authToken=${? TWILIO_AUTH_TOKEN}
cfp.twilioSMS.senderNumber=${? TWILIO_SENDER_NUMBER}
cfp.twilioSMS.mock=true
cfp.twilioSMS.mock=${? TWILIO_MOCK}

# Tags system
cfp.tags.active=false
cfp.tags.active=${? CFP_TAGS_ACTIVE}

# Maximum number of proposals per speaker
cfp.max.proposals=3
cfp.max.proposals=${? CFP_MAX_PROPOSALS}

# Security fix
gluon.username=${? GLUON_USERNAME}
gluon.password=${? GLUON_PASSWORD}
# This is the Gluon authentication token used to trigger a schedule refresh
gluon.auth.token=${? GLUON_AUTH_TOKEN}
# Token used by Gluon when it validates a Webuser with the CFP
gluon.inbound.token=${? GLUON_INBOUND_TOKEN}

cfp.sendProposalRefusedEmail=${? CFP_SEND_PROPOSAL_REFUSED_EMAIL}
